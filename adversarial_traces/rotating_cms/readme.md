# Rotating CMS
The rotating CMS application consists of 2 sketches (with the same number of columns and rows) that record counts for flows (a flow is defined by its src and dst ips). For a single time interval, we write to one sketch and clean the other sketch. In the next interval, we rotate the sketches - we write to the one we've just cleaned and clean the other one. We clean a single register per packet.

## Required packages for RL
The RL code requires the torch and gym packages, which can be installed with:
```
pip3 install torch gym
```

## Required Files
Parasol requires 5 files.
- Lucid file (``rotating_cms.dpt``): This contains the program logic 
- Extern definitions (``rotating_cms.py``): This is a python file that contains definitions of all externs used in the ``dpt`` program. These are mainly used to collect measurements while packets are processing.
- Optimization inputs (``rotating_cmsopt.json``): This is a json file that lists inputs to the optimization process. This must include: 
    - The size of the sketches (``symbolicvals``) because those are defined as symbolics in the lucid file (note that these will remain constant)
    - Initial paramater values for the trace (``traceparams``)
    - Bounds on those parameters (``traceparams``) 
    - Any additional parameters for optimization (``optparams``) - this only includes ``maxpkts`` right now, which is the max number of pkts that can be sent (this is used to set the ``max time`` field for the interpreter)
    - The name of the file containing concrete values for symbolics (this file is automatically generated; it should have the same name as the lucid file with the extension ``.symb``)
    - The name of the lucid file
    - The name of the files where measurements get written to (``outputfiles``). These files are written in ``rotating_cms.py`` and are read in ``simulator.py``. The contents of these files are returned by ``send_pkts`` in ``simulator.py``
    - The name of the optimization module (see below)
- Optimization module (``rotating_cmsopt.py``): This is a python file that contains the functions for generating a trace and calculating a cost for a particular trace based on the measurements taken by the externs (e.g., average error for CMS counts). It must include a class named ``Opt`` that implements the following functions:
    - Constructor that takes as input the program configuration (i.e., a dict of {symbolic name: value})
    - ``gen_traffic``: This function generates a trace to simulate. It takes as input ``traceparams`` (specified in ``rotating_cmsopt.json``) and returns a list of interpreter events (in json format) as bytes, to feed into the interactive interpreter. This function can also optionally add control plane commands to a trace - we add control plane commands to clean a sketch to the end of the event list for the rotating CMS. It can also compute ground truth for a trace; as we generate a trace, we store the ground truth counts for each flow to use later in calculating error.
    - ``calc_cost``: This function caclulates a user-defined cost based on measurements taken during simulation. It takes as input a list of measurements from each measurement file written by externs (e.g., for the rotating CMS, this is [ {flow id: estimated count}, [bits set for cms0, bits set for cms1] ]). It returns a cost for the particular trace and sketch configuration (e.g., average error across all flows for the rotating CMS).
    - ``init_simulation``: This function sets some parameters for the interpreter and saves them to a json file. It takes as input the max number of packets that can be sent during the simulation. This can also contain any other code that must be executed before the interpreter can run (e.g., certain applications require special events to happen first, before a trace is processed).
- Makefile: the script calls commands in the makefile to start the interpreter (it's not necessarily required, but it's simpler to use the make command). The makefile must include
    - ``interactive``: ``$(LUCID_DIR)/dpt -i --suppress-final-state {lucid_file}`` this starts the interpreter in interactive mode

## Running a Simulation
To generate traces and get back measurements taken during simulation, you only need to call functions in ``simulator.py``. The ``main`` function in ``simulator.py`` shows an example of how to generate traces for a single interval, get the measurements, and repeat. The workflow is:
- call ``init_simulation`` before generating traces
- for each interval, call ``send_pkts`` with the number of packets to send and the return values of ``init_simulation`` as input
- at the end of the simulation, call ``end_simulation``



