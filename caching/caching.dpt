/* data plane caching application */
// choose between cms and precision for eviction/insertion


// include cms, include precision
//include "defs.dpt"
include "precisioncachemodule.dpt"
include "cmscachemodule.dpt"

/* cache regs */
/* Memops */
/* externs */
// ^ defined in indiv module files

/* symbolics */
symbolic int entries;
symbolic size logentries;
symbolic size tables;
symbolic int cols;  // for cms only, but same interface
symbolic size logcols;
symbolic size rows;
symbolic bool eviction; // decide which struct to use for evictions

/* module */
module Cache = Cmscache if eviction else Precisioncache;
global Cache.t<<logentries,tables,logcols,rows>> c = Cache.create(entries,cols);
//global Cmscache.t<<logentries, tables, logcols, rows>> pc = Cmscache.create(entries,cols);
//global Precisioncache.t<<logentries, tables, logcols, rows>> pc = Precisioncache.create(entries,cols);


/* events */
entry event ip_in(int key, int<<3>> resubmit, int<<8>> resubmitted_min_stage, int cacheval);
exit event ip_out();

/* handler */
handle ip_in(int key, int<<3>> resubmit, int<<8>> resubmitted_min_stage, int cacheval) {
    resubmitted_min_stage = Cache.cache(c,key,resubmit,resubmitted_min_stage,cacheval);
    //resubmitted_min_stage = Cmscache.cache(pc,key,resubmit,resubmitted_min_stage,cacheval);
    //resubmitted_min_stage = Precisioncache.cache(pc,key,resubmit,resubmitted_min_stage,cacheval);
    if (resubmitted_min_stage == 0) {
        generate ip_out();
    }
    else {
        generate ip_in(key, 1, resubmitted_min_stage, key);
    }
}


