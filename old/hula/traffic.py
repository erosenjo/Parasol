# generate hula traffic
# this is dependent on the topology
# this is example is simple tree topo (could extend to fat tree)
# hula probes -> probe pkts are generated by ToR switches every T seconds (default is 1s) and propogated throughout networking by multicast
#   use timestamp field for interpreter to make sure pkts generated according to T
# hula data pkts -> pkts destined for a host connected to ToR switch
#   use existing pcap and just change fields to make it easier

import json 
from scapy.all import *

def i2Hex (n):
    hstr = str(hex(int(n)))
    if "0x" in hstr:
        if len(hstr[2:]) == 1: return "0" + hstr[2:].upper()
        else: return hstr[2:].upper()
    else:
        return hstr.upper()

def hexadecimal (ip_addr):
    # 0xC00002EB ( Hexadecimal )
    return "0x" + "".join( map( i2Hex,  ip_addr.split(".") ) )

# TODO: gen some initialize events so mpu isn't 0 (otherwise it will always be min)

def probes():
    # 8 ToR switches that gen probes, gen every 1s (but stagger them)
    # ToR 1 -> port 1, 2 -> port 2, 3-8 -> port 3
    # ToR starts at time 0ns, then each starts 125000000 ns after that (evenly spaced)
    # 

def data():
    # pkts from one host to another
    # we're only looking at 1 switch, so it'll be from hosts 1-2 to rest of network, or to hosts 1-2 from rest of network
    # we can change port nums around to gen more flowlets (bc small num of ips)


# return ground truth 
def gen_traffic(pkts):
    info = {}
    info["switches"] = 1
    info["max time"] = 9999999
    info["default input gap"] = 100
    info["random seed"] = 0
    info["python file"] = "rtt.py"
    events = []
    with PcapReader(pkts) as pcap_reader:
        for pkt in pcap_reader:
            if not (pkt.haslayer(IP)) or not (pkt.haslayer(TCP)):
                continue
            src_int = int(hexadecimal(pkt[IP].src),0)
            dst_int = int(hexadecimal(pkt[IP].dst),0)
            pktlen = pkt[IP].len
            ihl = pkt[IP].ihl
            offset = pkt[TCP].dataofs
            seq = pkt[TCP].seq
            ack = pkt[TCP].ack
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport
            timestamp = float(pkt.time)
            # getting int value of flags
            # this is so annoying is there a better way?
            f_str = pkt[TCP].flags
            f_int = 0
            if "F" in f_str:
                f_int += 1
            if "S" in f_str:
                f_int += 2
            if "R" in f_str:
                f_int += 4
            if "P" in f_str:
                f_int += 8
            if "A" in f_str:
                f_int += 16
            args = [f_int, pktlen, ihl, offset, seq, ack, src_int, dst_int, sport, dport, timestamp]
            p = {"name":"tcp_in", "args":args}
            events.append(p)
            if len(events) > 200:
                break

    info["events"] = events
    with open('rtt.json', 'w') as f:
        json.dump(info, f, indent=4)

    #return ground_truth = [0]*100
    return len(events) 


#exact = gen_traffic("univ1_pt1.pcap")
#print(exact)


#gen_traffic("univ1_pt1.pcap")

